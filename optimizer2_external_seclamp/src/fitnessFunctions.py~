from math import fsum,sqrt
from string import split,strip,replace







class spike_frame():
    def __init__(self,start,start_val,peak,peak_val,stop,stop_val):
        self.start_pos=start
        self.stop_pos=stop
        self.peak=peak
        self.peak_val=peak_val
        self.start_val=start_val
        self.stop_val=stop_val
        
class spike(spike_frame):
    def __init(self,start,start_val,peak,peak_val,stop,stop_val,spike):
        spike_frame.__init__(self, start, start_val, peak, peak_val, stop, stop_val)
        self.s=spike#vector, with the spike in it
        

class fitnessFunctions():
    def __init__(self,reader_object,threshold,model_object,option_object,args):
        self.fitnes=[]
        self.thres=threshold
        self.d_spike=[]
        self.m_spike=[]
        self.model=model_object
        self.option=option_object
        self.reader=reader_object
        #self.current_pop=0
        self.arguments=args
        print self.arguments
        self.fun_dict={"Average Squared Error": self.ase,
                       "Spike Count": self.countSpike, 
                       "Combinations": self.combineFeatures, 
                       "Averaged Squared Error II": self.spike_ase,
                       "Feature Extractor I": self.smallFeaturesExtractor}
        self.calc_dict={"Average Squared Error": self.calc_ase,
                        "Spike Count": self.calc_spike, 
                        "Averaged Squared Error II": self.calc_spike_ase,
                        "Spike Rate": self.spike_rate,
                        "ISI Differences": self.isi_differ,
                        "Latency to 1st Spike": self.first_spike,
                        "AP Overshoot": self.AP_overshoot,
                        "AHP Depth": self.AHP_depth,
                        "AP Width": self.AP_width}
        try:
            s=self.option.GetUFunString()
            s=replace(s,"h.","self.model.hoc_obj.")
            exec(compile(replace(s,"h(","self.model.hoc_obj("),'<string>','exec'))
            self.usr_fun_name=self.option.GetUFunString().split("\n")[3][self.option.GetUFunString().split("\n")[3].find(" ")+1:self.option.GetUFunString().split("\n")[3].find("(")]
            self.usr_fun=locals()[self.usr_fun_name]
        except SyntaxError:
            print "Your function contained syntax errors!! Please fix them!"
        except IndexError:
            pass
            
        
        
    def compileUDF(self,section,settings,params):
        
       
        if self.option.GetUFunString()=='':
            for sec in section:
                if len(split(sec," "))==3:
                    self.model.SetChannelParameters(strip(split(sec," ")[0]),strip(split(sec," ")[1]),strip(split(sec," ")[2]),params[section.index(sec)])
                
                else:
                    self.model.SetMorphParameters(strip(split(sec," ")[0]),strip(split(sec," ")[1]),params[section.index(sec)])
        else:
            #cal the user def.ed function
            self.usr_fun(self,params)
            
            
        
        
    def modelRunner(self,candidates):
        
        params=candidates
        section=self.arguments.get("section",0)
        settings=self.arguments.get("settings",0)
        self.compileUDF(section, settings, params)
        self.model.RunControll(settings)

        
        #compare the incoming traces, based on the spike rate, 
        #which is defined as (number of spikes)/trace[first spikes:last spike]
        #it returns a normalized value
        #if the model trace doesn't contain any spikes then the function returns 2
    def spike_rate(self,a,b):
        spikes=self.detectSpike( a, b)
        print "spike rate:"
        print "mod: ", len(spikes[0])
        print "exp: ", len(spikes[1])
        if len(spikes[0])<1 or len(spikes[1])<1:
            return 1000
        mod_begin=spikes[0][0].start_pos
        mod_end=spikes[0][-1].stop_pos
        mod_num_o_spikes=len(spikes[0])
        
        exp_begin=spikes[1][0].start_pos
        exp_end=spikes[1][-1].stop_pos
        exp_num_o_spikes=len(spikes[1])
        
        mod_rate=float(mod_num_o_spikes)/float(mod_end-mod_begin)
        exp_rate=float(exp_num_o_spikes)/float(exp_end-exp_begin)
    
        print abs(mod_rate-exp_rate)/max(mod_rate,exp_rate)
        return abs(mod_rate-exp_rate)/max(mod_rate,exp_rate) 
    
        #compares the two traces based on the 
        #differences in the interspike intervals (isi)
        #normalized
        #returns 2 if model trace has no spikes
    def isi_differ(self,a,b):#k. tpl szamolva:The value of k was either
#four ISIs or one-fifth of the total number of ISIs, whichever was the smaller
#of the two

        print "isi difference:"
        spikes=self.detectSpike( a, b)
        tmp=abs(len(spikes[0])-len(spikes[1]))
        print "mod: ", len(spikes[0])
        print "exp: ", len(spikes[1])
        if len(spikes[0])<2 or len(spikes[1])<2:
            return 1
        k=0
        limit=min(4,len(spikes[1])//2)
        for s1,s2 in zip(range(len(spikes[0])),range(len(spikes[1]))):
            try:
                k+=1
                if k>limit:
                    tmp+=abs((spikes[0][s1+1].peak-spikes[0][s1].peak)/(spikes[0][-1].peak-spikes[0][0].peak)
                        -(spikes[1][s2+1].peak-spikes[1][s2].peak)/(spikes[1][-1].peak-spikes[1][0].peak))
                
            except IndexError:
                pass
        print tmp
        return tmp
    
    
        #compares the two traces based on the latency of the first spikes
        #abs(spikes[0][0].start_pos/len(a)-spikes[1][0].start_pos/len(b))normalized
    def first_spike(self,a,b):
        print "first spike"
        spikes=self.detectSpike( a, b)
        print "mod: ", len(spikes[0])
        print "exp: ", len(spikes[1])
        if len(spikes[0])<1 or len(spikes[1])<1:
            return 1000
        print abs(spikes[0][0].start_pos/len(a)-spikes[1][0].start_pos/len(b))
        return abs(spikes[0][0].start_pos/len(a)-spikes[1][0].start_pos/len(b))
    
    
        #compares the traces based on the spike heights (heights calculated as the following:
        #abs(peak avlue-spike threshold) )
        #normalized
    def AP_overshoot(self,a,b):
        print "AP oveshoot:"
        spikes=self.detectSpike( a, b)
        print "mod: ", len(spikes[0])
        print "exp: ", len(spikes[1])
        if len(spikes[0])<1 or len(spikes[1])<1:
            return 1000
        tmp=[abs((s1.peak_val-self.thres)-(s2.peak_val-self.thres)) for s1,s2 in zip(spikes[0],spikes[1])]
        print fsum(tmp)/max(tmp)
        return  fsum(tmp)/max(tmp)
    
    
        #compares the two traces based on the after-hyperpolarization depth
        #basically finds the minimum value between spikes and compares them
        #normalized
    def AHP_depth(self,a,b):
        print "AHP depth:"
        spikes=self.detectSpike( a, b)
        print "mod: ", len(spikes[0])
        print "exp: ", len(spikes[1])
        if len(spikes[0])<1 or len(spikes[1])<1:
            return 1000
        tmp=0
        for s1,s2 in zip(range(len(spikes[0])),range(len(spikes[1]))):
            try:
                tmp+=abs((min(a[spikes[0][s1].stop_pos:spikes[0][s2+1].start_pos]))/min(a)-(min(b[spikes[1][s2].stop_pos:spikes[1][s2+1].start_pos]))/min(b))
            except IndexError:
                tmp+=abs((min(a[spikes[0][s1].stop_pos-1:-1]))-(min(b[spikes[1][s2].stop_pos-1:-1])))

                
        print tmp
        return tmp
    
    
        #compares the traces based on the width of the action potentials
        #the width is computed at the base of the spike and at the middle of the spike
        #not normalized 
    def AP_width(self,a,b):#atlagos spike szelesseget, vagy utolso/elso vagy csak az elso
        print "AP width:"
        
        spikes=self.detectSpike( a, b)
        print "mod: ", len(spikes[0])
        print "exp: ", len(spikes[1])
        if len(spikes[0])<1 or len(spikes[1])<1:
            return 1000
        avg1=0.0
        avg2=0.0
        for s1,s2 in zip(spikes[0],spikes[1]):
            avg1+=s1.peak+len(a[s1.peak:s1.stop_pos])/2-s1.start_pos+len(a[s1.start_pos:s1.peak])/2
            avg2+=s2.peak+len(b[s2.peak:s2.stop_pos])/2-s2.start_pos+len(b[s2.start_pos:s2.peak])/2
#            avg1=s1.start_pos+len(a[s1.start_pos:s1.peak])/2
#            avg2=s1.peak+len(a[s1.peak:s1.stop_pos])/2
#            avg3=s2.start_pos+len(b[s2.start_pos:s2.peak])/2
#            avg4=s2.peak+len(b[s2.peak:s2.stop_pos])/2
#            tmp+=abs((s1.stop_pos-s1.start_pos)-(s2.stop_pos-s2.start_pos))+abs((a[avg1]-a[avg2])-(a[avg3]-a[avg4]))
        avg1=float(avg1)/float(len(spikes[0]))
        avg2=float(avg2)/float(len(spikes[1]))
        print abs(avg1-avg2)
        return abs(avg1-avg2)

    
        #calculates the averaged squared error's of the close proximity of spikes
    def calc_spike_ase(self,a,b):
        tmp=[]
        spikes=self.detectSpike(a,b)
        print "mod: ", len(spikes[0])
        print "exp: ", len(spikes[1])
        if len(spikes[1])<1:
            print "no spike"
        for i,s in enumerate(spikes[1]):
            try:
                tmp.append(self.calc_ase(a[s.stop_pos:spikes[1][i+1].start_pos],b[s.stop_pos:spikes[1][i+1].start_pos] ))
            except IndexError:
                pass
        print fsum(tmp)/len(spikes[1])
        return fsum(tmp)/len(spikes[1])
        
        # averaged squared error 
    def calc_ase(self,model,exp):
        #print "ase:"
        temp=[]
        for n in range(min([len(exp),len(model)])):
            if model[n]>100 or model[n]<-100:
                return 100
            try:
                temp.append(pow(exp[n]-model[n],2))
            except OverflowError:
                return 100
            except TypeError:
                return 2
        
        return (sqrt(fsum(temp)/len(temp)))/(max(max(exp,model))-min(min(exp,model)))
    
    def ase(self,candidates,args):
        #temp=[]
        self.fitnes=[]
        temp_fit=0
        #param=self.option.GetModelStimParam()
        #parameter=param
        self.model.CreateStimuli(self.option.GetModelStim())
        for l in candidates:
            print l
            for k in range(len(self.reader.data[0])):
                param=self.option.GetModelStimParam()
                parameter=param
                parameter[0]=param[0][k]
                self.model.SetStimuli(parameter)
                self.modelRunner(l)
                #for n in range(len(self.reader.data)):
                #    temp.append(pow(self.reader.GetTrace(k)[n]-self.model.record[k][n],2))
                temp_fit+=self.calc_ase(self.model.record[k],self.reader.GetTrace(k))#fsum(temp)/len(temp)
                
            self.fitnes.append(temp_fit)
            print temp_fit
            temp_fit=0
            #self.current_pop+=1
        return self.fitnes


    def spike_ase(self,candidates,args):
        #temp=[]
        self.fitnes=[]
        temp_fit=0
        #param=self.option.GetModelStimParam()
        #parameter=param
        self.model.CreateStimuli(self.option.GetModelStim())
        for l in candidates:
            print l
            for k in range(len(self.reader.data[0])):
                param=self.option.GetModelStimParam()
                parameter=param
                parameter[0]=param[0][k]
                self.model.SetStimuli(parameter)
                self.modelRunner(l)                
                temp_fit+=self.calc_spike_ase(self.model.record[k],self.reader.GetTrace(k))#fsum(temp)/len(temp)
                
            self.fitnes.append(temp_fit)
            print temp_fit
            temp_fit=0
            #self.current_pop+=1
        return self.fitnes


        
    # spike detection
    def detectSpike(self,vect,vect2):
        start_pos=0
        stop_pos=0
        start=0
        spikes=[]
        temp1=[]
        temp2=[]
        for n in range(len(vect)):
            if vect[n]>self.thres and start==0:
                start_pos=n
                start=1
            if vect[n]<self.thres and start==1:
                stop_pos=n
                start=0
                s=spike_frame(start_pos,vect[start_pos],vect.index(max(vect[start_pos:stop_pos])),max(vect[start_pos:stop_pos]),stop_pos,vect[stop_pos])
                temp1.append(s)
        start_pos=0
        stop_pos=0
        start=0
        for n in range(len(vect2)):
            if vect2[n]>self.thres and start==0:
                start_pos=n
                start=1
            if vect2[n]<self.thres and start==1:
                stop_pos=n
                start=0
                s=spike_frame(start_pos,vect2[start_pos],vect2.index(max(vect2[start_pos:stop_pos])),max(vect2[start_pos:stop_pos]),stop_pos,vect2[stop_pos])
                temp2.append(s)
        
        spikes.append(temp1)#model
        spikes.append(temp2)#exp
        
            
        return spikes
    
    def calc_spike(self,a,b):
        temp_fit=0
        spikes=self.detectSpike(a,b)
        mod_spike=len(spikes[0])
        exp_spike=len(spikes[1])
        print "mod: ", mod_spike
        print "exp: ", exp_spike            
        try:
            temp_fit+=float(abs(mod_spike-exp_spike))/max( float(exp_spike),float(mod_spike-1) )
        except ZeroDivisionError:
            print "error"
            temp_fit+=1
        print temp_fit
        return temp_fit

    
    
    def countSpike(self,candidates,args):
        temp_fit=0
        self.fitnes=[]
        #spikes=[]
        #param=self.option.GetModelStimParam()
        #parameter=param
        self.model.CreateStimuli(self.option.GetModelStim())
        for l in candidates:
            print l
            for k in range(len(self.reader.data[0])):
                #parameter[0]=param[0][k]
                param=self.option.GetModelStimParam()
                parameter=param
                parameter[0]=param[0][k]
                self.model.SetStimuli(parameter)
                self.modelRunner(l)
                temp_fit+=self.calc_spike(self.model.record[k],self.reader.GetTrace(k))
            self.fitnes.append(temp_fit)
            print temp_fit
            temp_fit=0         
            
            #self.current_pop+=1
        return self.fitnes
    
    def combineFeatures(self,candidates,args):
        self.fitnes=[]
        features=self.arguments.get("feat",[self.ase])
        weigths=self.arguments.get("weights",[1/float(len(features))]*len(features))
        temp_fit=0
        self.model.CreateStimuli(self.option.GetModelStim())
        for l in candidates:
            print l
            for k in range(len(self.reader.data[0])):
                param=self.option.GetModelStimParam()
                parameter=param
                parameter[0]=param[0][k]
                self.model.SetStimuli(parameter)
                self.modelRunner(l)
                for f,w in zip(features,weigths):
                    temp_fit+=w*(self.calc_dict[f]( self.model.record[k],self.reader.GetTrace(k) ))
                    
            self.fitnes.append(temp_fit)
            print temp_fit
            temp_fit=0
        return self.fitnes
    
    
    def smallFeaturesExtractor(self,candidates,args):
        #temp=[]
        self.fitnes=[]
        temp_fit=0
        #param=self.option.GetModelStimParam()
        #parameter=param
        self.model.CreateStimuli(self.option.GetModelStim())
        for l in candidates:
            print l
            for k in range(len(self.reader.data[0])):
                param=self.option.GetModelStimParam()
                parameter=param
                parameter[0]=param[0][k]
                self.model.SetStimuli(parameter)
                self.modelRunner(l)
                #for n in range(len(self.reader.data)):
                #    temp.append(pow(self.reader.GetTrace(k)[n]-self.model.record[k][n],2))
                for f in [self.calc_ase,self.spike_rate,self.isi_differ,self.first_spike,self.AP_overshoot,self.AHP_depth,self.AP_width]:
                    temp_fit+=f(self.model.record[k],self.reader.GetTrace(k))
                
            self.fitnes.append(temp_fit)
            print temp_fit
            temp_fit=0
            #self.current_pop+=1
        return self.fitnes

                    

                
                
    
            

#
#
#
#class spike_frame():
#    def __init__(self,start,start_val,peak,peak_val,stop,stop_val):
#        self.start_pos=start
#        self.stop_pos=stop
#        self.peak=peak
#        self.peak_val=peak_val
#        self.start_val=start_val
#        self.stop_val=stop_val
#        
#class spike(spike_frame):
#    def __init(self,start,start_val,peak,peak_val,stop,stop_val,spike):
#        spike_frame.__init__(self, start, start_val, peak, peak_val, stop, stop_val)
#        self.s=spike#vector, with the spike in it
#        
#
#class fitnessFunctions():
#    def __init__(self,reader_object,threshold,model_object,option_object,args):
#        self.fitnes=[]
#        self.thres=threshold
#        self.d_spike=[]
#        self.m_spike=[]
#        self.model=model_object
#        self.option=option_object
#        self.reader=reader_object
#        #self.current_pop=0
#        self.arguments=args
#        print self.arguments
#        self.fun_dict={"Average Squared Error": self.ase,"Spike Count": self.countSpike, "Combinations": self.combineFeatures}
#        self.calc_dict={"Average Squared Error": self.calc_ase,"Spike Count": self.detectSpike}
#        try:
#            exec(compile(replace(self.option.GetUFunString(),"h(","self.model.hoc_obj("),'<string>','exec'))
#            self.usr_fun_name=self.option.GetUFunString().split("\n")[3][self.option.GetUFunString().split("\n")[3].find(" ")+1:self.option.GetUFunString().split("\n")[3].find("(")]
#            self.usr_fun=locals()[self.usr_fun_name]
#        except SyntaxError:
#            print "Your function contained syntax errors!! Please fix them!"
#        except IndexError:
#            pass
#            
#        
#        
#    def compileUDF(self,section,settings,params):
#        
#       
#        if self.option.GetUFunString()=='':
#            for sec in section:
#                if len(split(sec," "))==3:
#                    self.model.SetChannelParameters(strip(split(sec," ")[0]),strip(split(sec," ")[1]),strip(split(sec," ")[2]),params[section.index(sec)])
#                
#                else:
#                    self.model.SetMorphParameters(strip(split(sec," ")[0]),strip(split(sec," ")[1]),params[section.index(sec)])
#        else:
#            #cal the user def.ed function
#            self.usr_fun(self,params)
#            
#            
#        
#        
#    def modelRunner(self,candidates):
#        
#        params=candidates
#        section=self.arguments.get("section",0)
#        settings=self.arguments.get("settings",0)
#        self.compileUDF(section, settings, params)
#        self.model.RunControll(settings)
#
#        
#        
#    # averaged squared error 
#    def calc_ase(self,model,exp):
#        temp=[]
#        for n in range(min([len(exp),len(model)])):
#            try:
#                temp.append(pow(exp[n]-model[n],2))
#            except TypeError:
#                return 10000000000000
#        print (sqrt(fsum(temp)/len(temp)))/(max(max(exp,model))-min(min(exp,model)))
#        return (sqrt(fsum(temp)/len(temp)))/(max(max(exp,model))-min(min(exp,model)))
#    
#    def ase(self,candidates,args):
#        #temp=[]
#        self.fitnes=[]
#        temp_fit=0
#        #param=self.option.GetModelStimParam()
#        #parameter=param
#        self.model.CreateStimuli(self.option.GetModelStim())
#        for l in candidates:
#            print l
#            for k in range(len(self.reader.data[0])):
#                param=self.option.GetModelStimParam()
#                parameter=param
#                parameter[0]=param[0][k]
#                self.model.SetStimuli(parameter)
#                self.modelRunner(l)
#                #for n in range(len(self.reader.data)):
#                #    temp.append(pow(self.reader.GetTrace(k)[n]-self.model.record[k][n],2))
#                temp_fit+=self.calc_ase(self.reader.GetTrace(k), self.model.record[k])#fsum(temp)/len(temp)
#                
#            self.fitnes.append(temp_fit)
#            print temp_fit
#            temp_fit=0
#            #self.current_pop+=1
#        return self.fitnes
#        
#    # spike detection
#    def detectSpike(self,vect,vect2):
#        start_pos=0
#        stop_pos=0
#        start=0
#        spikes=[]
#        temp1=[]
#        temp2=[]
#        for n in vect:
#            if n>self.thres and start==0:
#                start_pos=vect.index(n)
#                start=1
#            if n<self.thres and start==1:
#                stop_pos=vect.index(n)
#                start=0
#                s=spike_frame(start_pos,vect[start_pos],vect.index(max(vect[start_pos:stop_pos])),max(vect[start_pos:stop_pos]),stop_pos,vect[stop_pos])
#                temp1.append(s)
#        start_pos=0
#        stop_pos=0
#        start=0
#        for n in vect2:
#            if n>self.thres and start==0:
#                start_pos=vect2.index(n)
#                start=1
#            if n<self.thres and start==1:
#                stop_pos=vect2.index(n)
#                start=0
#                s=spike_frame(start_pos,vect2[start_pos],vect2.index(max(vect2[start_pos:stop_pos])),max(vect2[start_pos:stop_pos]),stop_pos,vect2[stop_pos])
#                temp2.append(s)
#        
#        spikes.append(temp1)#model
#        spikes.append(temp2)#exp
#        
#            
#        return spikes
#    
#    def countSpike(self,candidates,args):
#        temp_fit=0
#        self.fitnes=[]
#        spikes=[]
#        #param=self.option.GetModelStimParam()
#        #parameter=param
#        self.model.CreateStimuli(self.option.GetModelStim())
#        for l in candidates:
#            print l
#            for k in range(len(self.reader.data[0])):
#                #parameter[0]=param[0][k]
#                param=self.option.GetModelStimParam()
#                parameter=param
#                parameter[0]=param[0][k]
#                self.model.SetStimuli(parameter)
#                self.modelRunner(l)
#                spikes=self.detectSpike(self.model.record[k],self.reader.GetTrace(k))
#                mod_spike=len(spikes[0])
#                exp_spike=len(spikes[1])            
#                print "model_spike: ",mod_spike
#                print "exp_spike: ",exp_spike
#                try:
#                    temp_fit+=float(abs(mod_spike-exp_spike))/max( float(exp_spike),float(mod_spike-1) )
#                except ZeroDivisionError:
#                    print "error"
#                    temp_fit+=1
#            self.fitnes.append(temp_fit)
#            print temp_fit
#            temp_fit=0
#            #self.current_pop+=1
#        return self.fitnes
#    
#    def combineFeatures(self,candidates,args):
#        self.fitnes=[]
#        features=self.arguments.get("feat",[self.ase])
#        weigths=self.arguments.get("weights",[1/float(len(features))]*len(features))
#        temp_fit=0
#        self.model.CreateStimuli(self.option.GetModelStim())
#        for l in candidates:
#            print l
#            for k in range(len(self.reader.data[0])):
#                param=self.option.GetModelStimParam()
#                parameter=param
#                parameter[0]=param[0][k]
#                self.model.SetStimuli(parameter)
#                self.modelRunner(l)
#                for f,w in zip(features,weigths):
#                    temp_fit+=w*(self.calc_dict[f]( self.model.record[k],self.reader.GetTrace(k)))
#                    
#            self.fitnes.append(temp_fit)
#            print temp_fit
#            temp_fit=0
#        return self.fitnes
#                    
#
#                
#                
#    
            
///////// declaring the parameters /////////
create shead[1], sneck[1]
sneck[0].L = 0.0001			// because of the declaration 1 spinehead and 1 spineneck is created, but not connectied to anything
sneck[0].diam = 0.0001
shead[0].L = 0.0001								// get minimal parameters so they do not disturb anything
shead[0].diam = 0.0001

Vleak = -65											// leak channel reversal potential [mV]
//global_ra = 150.00 										// internal resistivity [ohm*cm]
Cm = 1 //0.75												// specific membrane capacitance [uF/cm^2]
Rm_soma = 20000									// specific membrane resistivity at the soma [ohm*cm^2]
gkad = 0.036          								// maximum A-type potassium channel conductance [uS]

///////// spine morphologic parameters /////////
sneck_diam = 0.077 											// Harnett 2012
sneck_len = 1.58										// spine neck and head diameter and length [um] 
shead_diam = 0.5 
shead_len = 0.5 

///////// channel densities /////////
caR_spine = 0.03 												// Katz 2009
sAHP_spine = 0.001
mAHP_spine = 0.001


func spine_density(){
	dend_n = $1
	
	dendrite[dend_n] ifsec all_axon {
		dens = 0

	}
	dendrite[dend_n] ifsec apical_dendrites {
		dens = 0.560637

	}

	dendrite[dend_n] ifsec basal_dendrites {
		dens = 2.854114

	}

	dendrite[dend_n] ifsec oblique_dendrites {
		dens = 3.522589

	}

	dendrite[dend_n] ifsec trunk {
		dens = 4.516117
	
	}
	
	return dens
}

func avg_diam(){
	
	dend_n = $1
	
	dendrite[dend_n] ifsec all_axon {

		average_diam = dendrite[dend_n].diam
	}
	dendrite[dend_n] ifsec apical_dendrites {

		average_diam = 0.386
	}

	dendrite[dend_n] ifsec basal_dendrites {

		average_diam = 0.336
	}

	dendrite[dend_n] ifsec oblique_dendrites {

		average_diam = 0.5
	}

	dendrite[dend_n] ifsec trunk {

		average_diam = 1.56
	}
	
	return average_diam
	
}

proc create_spines(){															// the first cluster should be the stimulated one
// all_spines
	
	all_spines = $1		
	create shead[all_spines+1], sneck[all_spines+1]

	for spi=0, all_spines{														// get minimal parameters, to all spines
		sneck[spi].L = 0.0001														
		sneck[spi].diam = 0.0001
		shead[spi].L = 0.0001
		shead[spi].diam = 0.0001
	}

}


proc fix_number_spines(){
	selected_dend = $1
	loc_first_spine = $2
	dist_spines = 1/spine_density(selected_dend)	
	cre_spines = $3
	length = dendrite[selected_dend].L
    F_factor_correction_with_spines(selected_dend, (cre_spines/length))              //visszacsinalja a membrankapacitasos cuccot azon a dendriten ahol explicit vannak a spineok
	addspines(cre_spines,loc_first_spine,dist_spines,sneck_diam,sneck_len,shead_diam,shead_len, length, selected_dend)
}

proc full_covered_with_spines(){
	selected_dend = $1
	loc_first_spine = 0.01
	dist_spines = 1/spine_density(selected_dend)	
	cre_spines=int(length/dist_spines)
	F_factor_correction_with_spines(selected_dend, spine_density(selected_dend))              //visszacsinalja a membrankapacitasos cuccot azon a dendriten ahol explicit vannak a spineok
	addspines(cre_spines,loc_first_spine,dist_spines,sneck_diam,sneck_len,shead_diam,shead_len, length, selected_dend)
}

current = 0
proc addspines(){
// cre_spines,loc_first_spine,dist_spines,sneck_diam,sneck_len,shead_diam,shead_len
	
	cre_spines = $1																// number of currently created spines
	loc_first_spine = $2  														// location of the first spine in unites relative to the branch								
	dist_spines = $3	  														// distance between the spines [um]
	sneck_diam = $4																// spine neck and head, diameter and length
	sneck_len = $5
	shead_diam = $6
	shead_len = $7
	len= $8
    selected_dend = $9

	access dendrite[selected_dend]

    dist_spines = dist_spines / len 											// convert um into relative distance
	///////// creating the spines /////////

	//print "current spine number: ", current
	
	switch_loc = 1																	// for the loc_spine
    for spi=current, cre_spines+current{										// generate all other spines

		switch_loc= switch_loc + 1

		sneck[spi].L = sneck_len												// morphologic parameters for the spines
    	sneck[spi].diam = sneck_diam
    	shead[spi].L = shead_len
    	shead[spi].diam = shead_diam
																				// creating the channels
    	sneck[spi] { 															// passiv channels are dominant on the spineneck
    	    insert Leak_pyr
            gmax_Leak_pyr = 4.94532951382e-06
            e_Leak_pyr = -47.9327733651
    	    Ra=100
    	    cm = Cm	
            insert cad_mod_for_ltp 															// calcium channel
            taur_cad_mod_for_ltp=14 														// changed parameter		
    	}
		
		
    	shead[spi] { 															// more channels on the spinehead, the stimulus come here
    	    insert Leak_pyr
            gmax_Leak_pyr = 4.94532951382e-06
            e_Leak_pyr = -47.9327733651
    	    Ra=100
    	    cm = Cm
    	    insert K_A_dist  														// A-type potassium channel
	    gmax_K_A_dist = dendrite[selected_dend].gmax_K_A_dist
	    insert K_A_prox
	    gmax_K_A_prox = dendrite[selected_dend].gmax_K_A_prox
    	    insert cad_mod_for_ltp 															// calcium channel
    	    taur_cad_mod_for_ltp=14 														// changed parameters
    	    depth_cad_mod_for_ltp=shead_diam/2	
	    insert car
	    pbar_car = 0.00001
	    insert CaL_pool2
	    gmax_CaL_pool2 = 0.01
            insert sKCa
            gk_sKCa = dendrite[selected_dend].gk_sKCa
            insert cat31
            insert cat32
            insert cat33

	    dendrite[dend_n] ifsec basal_dendrites {

		    pbar_cat31 = 0.00012175 * 0.01
                    pbar_cat32 = 0.0001104 * 0.01
                    pbar_cat33 = 0.0001785667 * 0.01
	    }

	    dendrite[dend_n] ifsec oblique_dendrites {

		    pbar_cat31 = 0.00012175 * 0.01
                    pbar_cat32 = 0.00012435 * 0.01
                    pbar_cat33 = 0.0001785667 * 0.01
	    }

            dendrite[dend_n] ifsec tuft {

		    pbar_cat31 = 0.00012175 * 0.01
                    pbar_cat32 = 0.0000213 * 0.01
                    pbar_cat33 =0.0001785667 * 0.01
	    }

    	}
			
		///////// connect the spines to the branch /////////
   
   
   
     	loc_spine = loc_first_spine + switch_loc * dist_spines
		if (loc_spine>1) {
	    	loc_spine=1

		}

		connect sneck[spi](0), loc_spine
     	connect shead[spi](0), sneck[spi](1)
	}

	current = current + cre_spines +1
	
	
}

proc F_factor_correction_with_spines() {

	dend_n = $1
	spine_dens = $2
	new_dens = spine_density(dend_n)-spine_dens

	//diameter=avg_diam(dend_n)
	diameter=dendrite[dend_n].diam
	spine_A_simplified_for_f_factor = (sneck_diam*sneck_len)+(shead_diam*shead_len)	// Harnett 2012, simplified because pi would have been thrown out anyway
	f_factor_orig = ((spine_A_simplified_for_f_factor*spine_density(dend_n))+ diameter)/diameter
	f_factor_corr = ((spine_A_simplified_for_f_factor*new_dens)+ diameter)/diameter

	if (f_factor_corr < 0) {
		print "Too many spines!!!!!"
		quit()		
	}
		
	dendrite[dend_n]{
		cm = dendrite[dend_n].cm * (f_factor_corr/f_factor_orig)
		gmax_Leak_pyr = dendrite[dend_n].gmax_Leak_pyr * (f_factor_corr/f_factor_orig)
		pbar_car = pbar_car * ((f_factor_corr/f_factor_orig)-1)
                gmax_K_A_prox = gmax_K_A_prox * (f_factor_corr/f_factor_orig)
                gmax_K_A_dist = gmax_K_A_dist * (f_factor_corr/f_factor_orig)
                gk_sKCa = gk_sKCa * (f_factor_corr/f_factor_orig)
                pbar_cat31 =  pbar_cat31 * (f_factor_corr/f_factor_orig)
                pbar_cat32 =  pbar_cat32 * (f_factor_corr/f_factor_orig)
                pbar_cat33 =  pbar_cat33 * (f_factor_corr/f_factor_orig)
	//	gmax_CaL_pool2 = dendrite[dend_n].gmax_CaL_pool2 + 0.01*((f_factor_corr/f_factor_orig)-1)
	}

}

////////////////////////////////////////////////////////
// procedure for using F factor


f_factor = 1																	// default F_factor, so it will change nothing

proc F_factor(){
	
	dend_n = $1
	
	//diameter=avg_diam(dend_n)
	diameter=dendrite[dend_n].diam
	spine_A_simplified_for_f_factor = (sneck_diam*sneck_len)+(shead_diam*shead_len)	// Harnett 2012, simplified because pi would have been thrown out anyway
	f_factor = 	((spine_A_simplified_for_f_factor*spine_density(dend_n))+ diameter)/diameter //egysegnyi hosszra
	
	dendrite[dend_n]{
		gmax_Leak_pyr = gmax_Leak_pyr*f_factor							// a method to neglect the spines
		cm = cm*f_factor				// equations from the Rapp et al. 1992 article
	//	gmax_Na_BG_dend = gmax_Na_BG_dend * f_factor
		Ra = Ra * 0.35
		insert car
		pbar_car = pbar_car * (f_factor-1)
                gmax_K_A_prox = gmax_K_A_prox * f_factor
                gmax_K_A_dist = gmax_K_A_dist * f_factor
                gk_sKCa = gk_sKCa * f_factor
                pbar_cat31 =  pbar_cat31 * f_factor
                pbar_cat32 =  pbar_cat32 * f_factor
                pbar_cat33 =  pbar_cat33 * f_factor
	//	gmax_CaL_pool2 = dendrite[dend_n].gmax_CaL_pool2 + 0.01*(f_factor-1)
	    //    gmax_CaL_pool2 = dendrite[dend_n].gmax_CaL_pool2 + 0.02
	}	

}


////////////////////////////////////////////////////////
// procedure to add  factor to all dendrites on the cell

proc add_F_factor_to_all_dendrites(){
	
	for i=0, 157 F_factor(i)

}
/*
objref cascade
proc subcell_cascade (){
	cascade = new casc_fromSBML(0.5)
	
	
}*/

